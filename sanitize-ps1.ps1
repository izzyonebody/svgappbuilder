<#sanitize-ps1.ps1I am GPT-5.2 Pro.Purpose:- Basic sanitization for text files (PowerShell scripts, Python, etc.)- Removes BOM, trims trailing whitespace, normalizes line endings to CRLF, optionally converts tabs to spaces.- Creates backups before modifying files.Usage examples:# Basic sanitize on all ps1 files in repo (interactive):.\sanitize-ps1.ps1 -Paths (Get-ChildItem -Recurse -Filter *.ps1 | Select-Object -ExpandProperty FullName)# Auto-apply changes without prompts and convert tabs to 4 spaces:.\sanitize-ps1.ps1 -Paths "src\**\*.ps1" -Fix -TabsToSpaces 4 -ForceNotes:- On Windows there is no executable bit; to run on Linux/WSL, set executable with chmod +x ./sanitize-ps1.ps1#>param(    [Parameter(Mandatory=$false)]    [string[]]$Paths = @("*.ps1"),    [switch]$Fix = $false,               # If provided, actually write changes; otherwise dry-run reporting    [int]$TabsToSpaces = 0,              # 0 = do not convert; otherwise number of spaces    [switch]$Backup = $true,    [switch]$Force = $false,             # apply without confirmation    [switch]$VerboseLogs = $false)function Normalize-Text {    param([string]$text, [int]$tabsToSpaces)    if ($text.Length -gt 0 -and $text[0] -eq [char]65279) { $text = $text.Substring(1) }    $text = $text -replace "(`r?`n|`r)", "`r`n"    $text = ($text -split "`r`n") | ForEach-Object { $_ -replace "\s+$", "" } | Join-String "`r`n"    if ($tabsToSpaces -gt 0) {        $text = $text -replace "`t", (" " * $tabsToSpaces)    }    return $text}# Expand globs/paths into file list$files = @()foreach ($p in $Paths) {    try {        $g = Get-ChildItem -Path $p -File -ErrorAction SilentlyContinue -Recurse        if ($g) { $files += $g.FullName } else {            if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }        }    } catch {        if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }    }}$files = $files | Sort-Object -Uniqueif (-not $files -or $files.Count -eq 0) {    Write-Output "No files matched; exiting."    exit 0}$modified = @()foreach ($file in $files) {    try {        $origBytes = [System.IO.File]::ReadAllBytes($file)        $text = $null        try {            $utf8no = New-Object System.Text.UTF8Encoding($false)            $text = $utf8no.GetString($origBytes)        } catch {            $text = [System.Text.Encoding]::Default.GetString($origBytes)        }    } catch {        Write-Warning "Unable to read $file: $_"        continue    }    $newText = Normalize-Text -text $text -tabsToSpaces $TabsToSpaces    if ($newText -ne $text) {        Write-Output "Changes detected: $file"        if ($VerboseLogs) { Write-Output "Preview (first 200 chars): `n$($newText.Substring(0, [Math]::Min(200,$newText.Length)))`n---" }        if ($Fix) {            if (-not $Force) {                $ans = Read-Host "Apply changes to $file? (y/N)"                if ($ans -notin @('y','Y','yes','Yes')) { Write-Output "Skipped $file"; continue }            }            if ($Backup) {                try { Copy-Item -LiteralPath $file -Destination "$file.bak" -Force } catch { Write-Warning "Backup failed for $file: $_" }            }            try {                $utf8no = New-Object System.Text.UTF8Encoding($false)                [System.IO.File]::WriteAllText($file, $newText, $utf8no)                Write-Output "Sanitized: $file"                $modified += $file            } catch {                Write-Warning "Failed to write $file: $_"            }        } else {            Write-Output "[Dry-run] Would sanitize: $file"        }    } else {        if ($VerboseLogs) { Write-Output "No changes needed: $file" }    }}if ($modified.Count -gt 0) {    Write-Output ""    Write-Output "Sanitized files:"    $modified | ForEach-Object { Write-Output " - $_" }} else {    Write-Output "No files were modified."}
