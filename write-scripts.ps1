<#write-scripts.ps1I am GPT-5.2 Pro.Purpose:- Write two utility scripts into the current repository:  1) convert-and-commit.ps1  2) sanitize-ps1.ps1Usage:  Save this file as write-scripts.ps1 in your repo root, then run:    pwsh -ExecutionPolicy Bypass -File .\write-scripts.ps1Notes:- This script writes files using UTF8 encoding (no BOM).- On Linux/WSL/macOS, it will attempt to set executable permission if 'chmod' is available.#># prepare content as single-quoted here-strings to avoid interpolation$convertScript = @'<#convert-and-commit.ps1I am GPT-5.2 Pro.Purpose:- Detect common BOMs/encodings and re-encode files to UTF-8 without BOM (configurable).- Make optional backups before modifying files.- Optionally stage and commit changed files to Git.Usage examples:# Dry-run, show files that would be changed:.\convert-and-commit.ps1 -Paths "src\*.ps1","*.md" -WhatIf# Convert all .ps1 files under current tree, create backups, do not commit:.\convert-and-commit.ps1 -Paths (Get-ChildItem -Recurse -Filter *.ps1 | Select-Object -ExpandProperty FullName)# Convert and commit:.\convert-and-commit.ps1 -Paths "src\**\*.ps1" -CommitMessage "Normalize encoding to UTF-8 no BOM" -PerformCommitNotes:- On Windows PowerShell, execution policy may block scripts; use an elevated prompt or set appropriate policy.- On Linux/WSL, make the script executable with: chmod +x ./convert-and-commit.ps1#>param(    [Parameter(Mandatory=$false)]    [string[]]$Paths = @("*.ps1"),    [string]$TargetEncoding = "utf8-nobom",   # supported: "utf8-nobom", "utf8-bom", "utf16le", "utf16be"    [switch]$Backup = $true,    [switch]$WhatIf = $false,    [string]$CommitMessage = "Normalize file encodings to UTF-8 (no BOM)",    [switch]$PerformCommit = $false,    [switch]$VerboseLogs = $false)function Get-EncodingFromBom {    param([byte[]]$bytes)    if ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {        return "utf8-bom"    } elseif ($bytes.Length -ge 2 -and $bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE) {        return "utf16le"    } elseif ($bytes.Length -ge 2 -and $bytes[0] -eq 0xFE -and $bytes[1] -eq 0xFF) {        return "utf16be"    } else {        return "unknown"    }}function Get-EncodingObject {    param([string]$name)    switch ($name.ToLower()) {        "utf8-nobom" { return (New-Object System.Text.UTF8Encoding($false)) }        "utf8-bom"   { return [System.Text.Encoding]::UTF8 }        "utf16le"    { return [System.Text.Encoding]::Unicode }        "utf16be"    { return [System.Text.Encoding]::BigEndianUnicode }        default      { throw "Unsupported target encoding: $name" }    }}# Expand globs/paths into file list$files = @()foreach ($p in $Paths) {    try {        $g = Get-ChildItem -Path $p -File -ErrorAction SilentlyContinue -Recurse        if ($g) { $files += $g.FullName } else {            if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }        }    } catch {        if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }    }}$files = $files | Sort-Object -Uniqueif (-not $files -or $files.Count -eq 0) {    Write-Output "No files matched the given Paths. Exiting."    exit 0}$targetEncObj = Get-EncodingObject -name $TargetEncoding$changed = @()foreach ($file in $files) {    if ($WhatIf) { Write-Output "[WhatIf] Would process: $file"; continue }    try {        $bytes = [System.IO.File]::ReadAllBytes($file)    } catch {        Write-Warning "Cannot read file: $file - $_"        continue    }    $current = Get-EncodingFromBom -bytes $bytes    if ($VerboseLogs) { Write-Output "File: $file  current BOM-detected encoding: $current" }    switch ($current) {        "utf8-bom" { $enc = [System.Text.Encoding]::UTF8 }        "utf16le"  { $enc = [System.Text.Encoding]::Unicode }        "utf16be"  { $enc = [System.Text.Encoding]::BigEndianUnicode }        default    { $enc = (New-Object System.Text.UTF8Encoding($false)) }    }    try {        $text = $enc.GetString($bytes)    } catch {        Write-Warning "Decoding failed for $file with detected encoding $current; skipping."        continue    }    $needChange = $false    if ($TargetEncoding -eq "utf8-nobom") {        if ($current -eq "utf8-bom") { $needChange = $true }    } else {        $map = @{            "utf8-nobom" = "utf8-nobom"            "utf8-bom"   = "utf8-bom"            "utf16le"    = "utf16le"            "utf16be"    = "utf16be"        }        $currentNormalized = if ($current -eq "unknown") { "utf8-nobom" } elseif ($current -eq "utf8-bom") { "utf8-bom" } else { $current }        if ($currentNormalized -ne $TargetEncoding) { $needChange = $true }    }    if (-not $needChange) {        if ($VerboseLogs) { Write-Output "Skipping (no change needed): $file" }        continue    }    if ($Backup) {        $bak = "$file.bak"        try {            Copy-Item -LiteralPath $file -Destination $bak -Force            if ($VerboseLogs) { Write-Output "Backup created: $bak" }        } catch {            Write-Warning "Failed to create backup for $file: $_"            continue        }    }    try {        $normalized = $text -replace "(`r?`n|`r)", "`r`n"        [System.IO.File]::WriteAllText($file, $normalized, $targetEncObj)        Write-Output "Re-encoded: $file (from $current -> $TargetEncoding)"        $changed += $file    } catch {        Write-Warning "Failed to write file $file: $_"        if ($Backup -and (Test-Path "$file.bak")) {            Copy-Item -LiteralPath "$file.bak" -Destination $file -Force            Write-Warning "Restored backup for $file"        }    }}if ($changed.Count -gt 0) {    Write-Output ""    Write-Output "Changed files:"    $changed | ForEach-Object { Write-Output " - $_" }} else {    Write-Output "No files were changed."}if ($PerformCommit -and $changed.Count -gt 0) {    Write-Output "Staging changed files and committing to Git..."    if ($WhatIf) { Write-Output "[WhatIf] git add -- $changed" }    else {        & git add -- $changed        if ($LASTEXITCODE -ne 0) { Write-Warning "git add failed"; exit 1 }        & git commit -m $CommitMessage        if ($LASTEXITCODE -ne 0) { Write-Warning "git commit failed" } else { Write-Output "Committed changes." }    }} elseif ($PerformCommit -and $changed.Count -eq 0) {    Write-Output "PerformCommit requested but no changed files to commit."}'@$sanitizeScript = @'<#sanitize-ps1.ps1I am GPT-5.2 Pro.Purpose:- Basic sanitization for text files (PowerShell scripts, Python, etc.)- Removes BOM, trims trailing whitespace, normalizes line endings to CRLF, optionally converts tabs to spaces.- Creates backups before modifying files.Usage examples:# Basic sanitize on all ps1 files in repo (interactive):.\sanitize-ps1.ps1 -Paths (Get-ChildItem -Recurse -Filter *.ps1 | Select-Object -ExpandProperty FullName)# Auto-apply changes without prompts and convert tabs to 4 spaces:.\sanitize-ps1.ps1 -Paths "src\**\*.ps1" -Fix -TabsToSpaces 4 -ForceNotes:- On Windows there is no executable bit; to run on Linux/WSL, set executable with chmod +x ./sanitize-ps1.ps1#>param(    [Parameter(Mandatory=$false)]    [string[]]$Paths = @("*.ps1"),    [switch]$Fix = $false,               # If provided, actually write changes; otherwise dry-run reporting    [int]$TabsToSpaces = 0,              # 0 = do not convert; otherwise number of spaces    [switch]$Backup = $true,    [switch]$Force = $false,             # apply without confirmation    [switch]$VerboseLogs = $false)function Normalize-Text {    param([string]$text, [int]$tabsToSpaces)    if ($text.Length -gt 0 -and $text[0] -eq [char]65279) { $text = $text.Substring(1) }    $text = $text -replace "(`r?`n|`r)", "`r`n"    $text = ($text -split "`r`n") | ForEach-Object { $_ -replace "\s+$", "" } | Join-String "`r`n"    if ($tabsToSpaces -gt 0) {        $text = $text -replace "`t", (" " * $tabsToSpaces)    }    return $text}# Expand globs/paths into file list$files = @()foreach ($p in $Paths) {    try {        $g = Get-ChildItem -Path $p -File -ErrorAction SilentlyContinue -Recurse        if ($g) { $files += $g.FullName } else {            if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }        }    } catch {        if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }    }}$files = $files | Sort-Object -Uniqueif (-not $files -or $files.Count -eq 0) {    Write-Output "No files matched; exiting."    exit 0}$modified = @()foreach ($file in $files) {    try {        $origBytes = [System.IO.File]::ReadAllBytes($file)        $text = $null        try {            $utf8no = New-Object System.Text.UTF8Encoding($false)            $text = $utf8no.GetString($origBytes)        } catch {            $text = [System.Text.Encoding]::Default.GetString($origBytes)        }    } catch {        Write-Warning "Unable to read $file: $_"        continue    }    $newText = Normalize-Text -text $text -tabsToSpaces $TabsToSpaces    if ($newText -ne $text) {        Write-Output "Changes detected: $file"        if ($VerboseLogs) { Write-Output "Preview (first 200 chars): `n$($newText.Substring(0, [Math]::Min(200,$newText.Length)))`n---" }        if ($Fix) {            if (-not $Force) {                $ans = Read-Host "Apply changes to $file? (y/N)"                if ($ans -notin @('y','Y','yes','Yes')) { Write-Output "Skipped $file"; continue }            }            if ($Backup) {                try { Copy-Item -LiteralPath $file -Destination "$file.bak" -Force } catch { Write-Warning "Backup failed for $file: $_" }            }            try {                $utf8no = New-Object System.Text.UTF8Encoding($false)                [System.IO.File]::WriteAllText($file, $newText, $utf8no)                Write-Output "Sanitized: $file"                $modified += $file            } catch {                Write-Warning "Failed to write $file: $_"            }        } else {            Write-Output "[Dry-run] Would sanitize: $file"        }    } else {        if ($VerboseLogs) { Write-Output "No changes needed: $file" }    }}if ($modified.Count -gt 0) {    Write-Output ""    Write-Output "Sanitized files:"    $modified | ForEach-Object { Write-Output " - $_" }} else {    Write-Output "No files were modified."}'@# Write files to disk as UTF8 (no BOM)$target1 = Join-Path -Path (Get-Location) -ChildPath "convert-and-commit.ps1"$target2 = Join-Path -Path (Get-Location) -ChildPath "sanitize-ps1.ps1"try {    $convertScript | Out-File -FilePath $target1 -Encoding utf8 -Force    Write-Output "Wrote: $target1"} catch {    Write-Error "Failed to write $target1 - $_"}try {    $sanitizeScript | Out-File -FilePath $target2 -Encoding utf8 -Force    Write-Output "Wrote: $target2"} catch {    Write-Error "Failed to write $target2 - $_"}# Attempt to set executable bit on Unix-like systems if chmod is availableif (Get-Command chmod -ErrorAction SilentlyContinue) {    try {        & chmod +x $target1        & chmod +x $target2        Write-Output "Set executable permission on Unix-like system for the two scripts."    } catch {        Write-Warning "chmod failed: $_"    }}Write-Output ""Write-Output "Next steps:"Write-Output "  Review the new files and adjust as needed."Write-Output "  To add and commit them to git, run:"Write-Output '    git add convert-and-commit.ps1 sanitize-ps1.ps1'Write-Output '    git commit -m "Add utilities: convert-and-commit and sanitize-ps1 scripts (encoding & sanitization helpers)"'# End of write-scripts.ps1