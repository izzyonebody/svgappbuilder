<#convert-and-commit.ps1I am GPT-5.2 Pro.Purpose:- Detect common BOMs/encodings and re-encode files to UTF-8 without BOM (configurable).- Make optional backups before modifying files.- Optionally stage and commit changed files to Git.Usage examples:# Dry-run, show files that would be changed:.\convert-and-commit.ps1 -Paths "src\*.ps1","*.md" -WhatIf# Convert all .ps1 files under current tree, create backups, do not commit:.\convert-and-commit.ps1 -Paths (Get-ChildItem -Recurse -Filter *.ps1 | Select-Object -ExpandProperty FullName)# Convert and commit:.\convert-and-commit.ps1 -Paths "src\**\*.ps1" -CommitMessage "Normalize encoding to UTF-8 no BOM" -PerformCommitNotes:- On Windows PowerShell, execution policy may block scripts; use an elevated prompt or set appropriate policy.- On Linux/WSL, make the script executable with: chmod +x ./convert-and-commit.ps1#>param(    [Parameter(Mandatory=$false)]    [string[]]$Paths = @("*.ps1"),    [string]$TargetEncoding = "utf8-nobom",   # supported: "utf8-nobom", "utf8-bom", "utf16le", "utf16be"    [switch]$Backup = $true,    [switch]$WhatIf = $false,    [string]$CommitMessage = "Normalize file encodings to UTF-8 (no BOM)",    [switch]$PerformCommit = $false,    [switch]$VerboseLogs = $false)function Get-EncodingFromBom {    param([byte[]]$bytes)    if ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {        return "utf8-bom"    } elseif ($bytes.Length -ge 2 -and $bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE) {        return "utf16le"    } elseif ($bytes.Length -ge 2 -and $bytes[0] -eq 0xFE -and $bytes[1] -eq 0xFF) {        return "utf16be"    } else {        return "unknown"    }}function Get-EncodingObject {    param([string]$name)    switch ($name.ToLower()) {        "utf8-nobom" { return (New-Object System.Text.UTF8Encoding($false)) }        "utf8-bom"   { return [System.Text.Encoding]::UTF8 }        "utf16le"    { return [System.Text.Encoding]::Unicode }        "utf16be"    { return [System.Text.Encoding]::BigEndianUnicode }        default      { throw "Unsupported target encoding: $name" }    }}# Expand globs/paths into file list$files = @()foreach ($p in $Paths) {    try {        $g = Get-ChildItem -Path $p -File -ErrorAction SilentlyContinue -Recurse        if ($g) { $files += $g.FullName } else {            if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }        }    } catch {        if (Test-Path $p) { $files += (Get-Item -LiteralPath $p).FullName }    }}$files = $files | Sort-Object -Uniqueif (-not $files -or $files.Count -eq 0) {    Write-Output "No files matched the given Paths. Exiting."    exit 0}$targetEncObj = Get-EncodingObject -name $TargetEncoding$changed = @()foreach ($file in $files) {    if ($WhatIf) { Write-Output "[WhatIf] Would process: $file"; continue }    try {        $bytes = [System.IO.File]::ReadAllBytes($file)    } catch {        Write-Warning "Cannot read file: $file - $_"        continue    }    $current = Get-EncodingFromBom -bytes $bytes    if ($VerboseLogs) { Write-Output "File: $file  current BOM-detected encoding: $current" }    switch ($current) {        "utf8-bom" { $enc = [System.Text.Encoding]::UTF8 }        "utf16le"  { $enc = [System.Text.Encoding]::Unicode }        "utf16be"  { $enc = [System.Text.Encoding]::BigEndianUnicode }        default    { $enc = (New-Object System.Text.UTF8Encoding($false)) }    }    try {        $text = $enc.GetString($bytes)    } catch {        Write-Warning "Decoding failed for $file with detected encoding $current; skipping."        continue    }    $needChange = $false    if ($TargetEncoding -eq "utf8-nobom") {        if ($current -eq "utf8-bom") { $needChange = $true }    } else {        $map = @{            "utf8-nobom" = "utf8-nobom"            "utf8-bom"   = "utf8-bom"            "utf16le"    = "utf16le"            "utf16be"    = "utf16be"        }        $currentNormalized = if ($current -eq "unknown") { "utf8-nobom" } elseif ($current -eq "utf8-bom") { "utf8-bom" } else { $current }        if ($currentNormalized -ne $TargetEncoding) { $needChange = $true }    }    if (-not $needChange) {        if ($VerboseLogs) { Write-Output "Skipping (no change needed): $file" }        continue    }    if ($Backup) {        $bak = "$file.bak"        try {            Copy-Item -LiteralPath $file -Destination $bak -Force            if ($VerboseLogs) { Write-Output "Backup created: $bak" }        } catch {            Write-Warning "Failed to create backup for $file: $_"            continue        }    }    try {        $normalized = $text -replace "(`r?`n|`r)", "`r`n"        [System.IO.File]::WriteAllText($file, $normalized, $targetEncObj)        Write-Output "Re-encoded: $file (from $current -> $TargetEncoding)"        $changed += $file    } catch {        Write-Warning "Failed to write file $file: $_"        if ($Backup -and (Test-Path "$file.bak")) {            Copy-Item -LiteralPath "$file.bak" -Destination $file -Force            Write-Warning "Restored backup for $file"        }    }}if ($changed.Count -gt 0) {    Write-Output ""    Write-Output "Changed files:"    $changed | ForEach-Object { Write-Output " - $_" }} else {    Write-Output "No files were changed."}if ($PerformCommit -and $changed.Count -gt 0) {    Write-Output "Staging changed files and committing to Git..."    if ($WhatIf) { Write-Output "[WhatIf] git add -- $changed" }    else {        & git add -- $changed        if ($LASTEXITCODE -ne 0) { Write-Warning "git add failed"; exit 1 }        & git commit -m $CommitMessage        if ($LASTEXITCODE -ne 0) { Write-Warning "git commit failed" } else { Write-Output "Committed changes." }    }} elseif ($PerformCommit -and $changed.Count -eq 0) {    Write-Output "PerformCommit requested but no changed files to commit."}
